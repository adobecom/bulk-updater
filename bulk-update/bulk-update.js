import fs from 'fs';
import { fetch } from '@adobe/fetch';
import { loadDocument } from './document-manager/document-manager.js';
import { validateMigration } from './validation/validation.js';

const delay = (milliseconds) => new Promise((resolve) => { setTimeout(resolve, milliseconds); });

function getJsonData(json, sheetName) {
  if (json[':type'] === 'multi-sheet') {
    return json[sheetName];
  }
  return json;
}

/**
 * Loads a list of entries from a Query Index.
 *
 * @param {*} url - The URL to fetch the data from.
 * @returns {Promise<string[]>} - List of entries.
 */
export async function loadQueryIndex(url, fetchFunction = fetch, fetchWaitMs = 500) {
  console.log(`Loading Query Index from ${url}`);
  const entries = [];
  await delay(fetchWaitMs);
  const response = await fetchFunction(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}`);
  }

  const json = await response.json();
  const { total, offset, limit, data } = getJsonData(json, 'sitemap');

  if (!Array.isArray(data)) throw new Error(`Invalid data format: ${url}`);
  entries.push(...data.map((entry) => entry.path || entry.entry || entry.url));
  const remaining = total - offset - limit;
  if (remaining > 0) {
    const nextUrl = new URL(url);
    nextUrl.searchParams.set('limit', limit);
    nextUrl.searchParams.set('offset', offset + limit);
    entries.push(...await loadQueryIndex(nextUrl.toString(), fetchFunction, fetchWaitMs));
  }

  return entries;
}

/**
 * Loads entries from a source. The source can be an array, a comma-separated string,
 * a string starting with '/', a URL pointing to a JSON file, a local path to a JSON file,
 * or a local path to a TXT file.
 *
 * @param {string|string[]} source - The list of entries to load from.
 * @returns {Promise<string[]>} - The loaded data as an array of strings.
 * @throws {Error} - If the list format or entry is unsupported.
 */
export async function loadListData(source, fetchFunction = fetch, fetchWaitMs = 500) {
  if (!source) return [];
  if (Array.isArray(source) || source.includes(',')) {
    const entries = Array.isArray(source) ? source : source.split(',');
    const loadedEntries = [];
    for (const entry of entries) {
      const loadedData = await loadListData(entry.trim(), fetchFunction, fetchWaitMs);
      if (loadedData) loadedEntries.push(...loadedData);
    }
    return loadedEntries;
  }

  const extension = source.includes('.') ? source.split('.').pop() : null;

  if (!extension) {
    return [source];
  }

  switch (extension) {
    case 'json':
      if (source.startsWith('http')) {
        return loadQueryIndex(source, fetchFunction, fetchWaitMs);
      }
      return loadListData(JSON.parse(fs.readFileSync(source, 'utf8').trim()), fetchFunction, fetchWaitMs);
    case 'txt':
      return loadListData(fs.readFileSync(source, 'utf8').trim().split('\n'), fetchFunction, fetchWaitMs);
    case 'html':
      return [source];
    default:
      throw new Error(`Unsupported list format or entry: ${source}`);
  }
}

/**
 * Generates the staged-content URL by localizing the stage path based on the entry path.
 *
 * @param {string} siteUrl - The base URL of the site.
 * @param {string} entry - The entry path.
 * @param {string} stagePath - The path to the stage.
 * @param {string[]} locales - An array of supported locales.
 * @returns {string} The staged URL.
 */
export function localizedStageUrl(siteUrl, entry, stagePath, locales = []) {
  const currentLocale = locales.find((locale) => locale && entry.startsWith(`/${locale}/`));
  const localizedPath = currentLocale ? entry.replace(`/${currentLocale}/`, `/${currentLocale}${stagePath}/`) : `${stagePath}${entry}`;

  return `${siteUrl}${localizedPath}`;
}

/**
 * Executes a bulk update operation using the provided migration function
 * Loads data from various sources and executes bulk update operations from the migration function.
 *
 * @param {object} config - The configuration object.
 * @param {function} migrate - The migration function.
 * @param {object} [reporter=null] - Override reporter object.
 * @returns {object} - The totals generated by the reporter.
 */
export default async function main(config, migrate, reporter = null) {
  config.reporter = reporter || config.reporter;
  const { list, outputDir, siteUrl, stagePath, locales } = config;
  const { length } = list;

  if (outputDir) {
    fs.mkdirSync(outputDir, { recursive: true });
    fs.writeFileSync(`${outputDir}/list.json`, JSON.stringify(config.list, null, 2));

    const output = list.map((entry) => [`${siteUrl}${entry}`, localizedStageUrl(siteUrl, entry, stagePath, locales)]);
    fs.writeFileSync(`${outputDir}/staged.json`, JSON.stringify(output, null, 2));
  }

  try {
    for (const [i, entry] of config.list.entries()) {
      const percentage = Math.round(((i + 1) / length) * 10000) / 100;
      console.log(`Processing entry ${i + 1} of ${length} (${percentage}%) ${entry}`);
      const document = await loadDocument(entry, config);
      await migrate(document);
      if (config.validateMigration) {
        await validateMigration(document, config);
      }
    }
  } catch (e) {
    console.error('Bulk Update Error:', e);
    config.reporter.log('Bulk Update Error', 'error', e.message, e.stack);
  }

  return config.reporter.generateTotals();
}

/**
 * Executes a bulk update operation using a migration script, loading data from various sources
 * and executing bulk update operations from the migration script.
 *
 * npm run bulk-update <project> <list>
 *
 * @param {string} migrationFolder - The folder containing the migration script.
 * @param {string|Array} list - The list of items to migrate.
 * @returns {Promise<void>} - A promise that resolves when the migration is complete.
 */
async function runMigration(migrationFolder, list) {
  const migrationFile = `${process.cwd()}/${migrationFolder}/migration.js`;

  console.log(`Running bulk update with migration script: ${migrationFile}`);
  if (!fs.existsSync(migrationFile)) {
    console.error(`Migration script not found at: ${migrationFile}`);
    process.exit(1);
  }

  try {
    // eslint-disable-next-line import/no-dynamic-require, global-require
    const migration = await import(migrationFile);

    if (!migration || !migration.init || !migration.migrate) {
      throw new Error('Missing init or migrate functions in migration script');
    }

    console.log('Initializing migration script:', migrationFile);
    const config = await migration.init(list);

    await main(config, migration.migrate);
    process.exit(0);
  } catch (error) {
    console.error('Error loading migration script:', error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const [migrationFolder, list] = args;

  runMigration(migrationFolder, list);
}
