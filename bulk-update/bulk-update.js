import fs from 'fs';
import { fetch } from '@adobe/fetch';
import { loadDocument } from './document-manager/document-manager.js';

const delay = (milliseconds) => new Promise((resolve) => { setTimeout(resolve, milliseconds); });

function getJsonData(json, sheetName) {
  if (json[':type'] === 'multi-sheet') {
    return json[sheetName];
  }
  return json;
}

/**
 * Loads a list of entries from a Query Index.
 *
 * @param {*} url - The URL to fetch the data from.
 * @returns {Promise<string[]>} - List of entries.
 */
export async function loadQueryIndex(url, fetchFunction = fetch, fetchWaitMs = 500) {
  console.log(`Loading Query Index from ${url}`);
  const entries = [];
  await delay(fetchWaitMs);
  const response = await fetchFunction(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}`);
  }

  const json = await response.json();
  const { total, offset, limit, data } = getJsonData(json, 'sitemap');

  if (!Array.isArray(data)) throw new Error(`Invalid data format: ${url}`);
  entries.push(...data.map((entry) => entry.path || entry.entry || entry.url));
  const remaining = total - offset - limit;
  if (remaining > 0) {
    const nextUrl = new URL(url);
    nextUrl.searchParams.set('limit', limit);
    nextUrl.searchParams.set('offset', offset + limit);
    entries.push(...await loadQueryIndex(nextUrl.toString(), fetchFunction));
  }

  return entries;
}

/**
 * Loads entries from a source. The source can be an array, a comma-separated string,
 * a string starting with '/', a URL pointing to a JSON file, a local path to a JSON file,
 * or a local path to a TXT file.
 *
 * @param {string|string[]} source - The list of entries to load from.
 * @returns {Promise<string[]>} - The loaded data as an array of strings.
 * @throws {Error} - If the list format or entry is unsupported.
 */
export async function loadListData(source, fetchFunction = fetch) {
  if (!source) return [];
  if (Array.isArray(source) || source.includes(',')) {
    const entries = Array.isArray(source) ? source : source.split(',');
    const loadedEntries = [];
    for (const entry of entries) {
      const loadedData = await loadListData(entry.trim(), fetchFunction);
      if (loadedData) loadedEntries.push(...loadedData);
    }
    return loadedEntries;
  }

  const extension = source.includes('.') ? source.split('.').pop() : null;

  if (!extension) {
    return [source];
  }

  switch (extension) {
    case 'json':
      if (source.startsWith('http')) {
        return loadQueryIndex(source, fetchFunction);
      }
      return loadListData(JSON.parse(fs.readFileSync(source, 'utf8').trim()), fetchFunction);
    case 'txt':
      return loadListData(fs.readFileSync(source, 'utf8').trim().split('\n'), fetchFunction);
    default:
      throw new Error(`Unsupported list format or entry: ${source}`);
  }
}

/**
 * Executes a bulk update operation using the provided migration function
 * Loads data from various sources and executes bulk update operations from the migration function.
 *
 * @param {object} config - The configuration object.
 * @param {function} migrate - The migration function.
 * @param {object} [reporter=null] - Override reporter object.
 * @returns {object} - The totals generated by the reporter.
 */
export default async function main(config, migrate, reporter = null) {
  config.reporter = reporter || config.reporter;

  try {
    for (const [i, entry] of config.list.entries()) {
      console.log(`Processing entry ${i + 1} of ${config.list.length} ${entry}`);
      const document = await loadDocument(entry, config);
      await migrate(document);
    }
  } catch (e) {
    console.error('Bulk Update Error:', e);
    config.reporter.log('Bulk Update Error', 'error', e.message, e.stack);
  }

  return config.reporter.generateTotals();
}

/**
 * Executes a bulk update operation using a migration script, loading data from various sources
 * and executing bulk update operations from the migration script.
 *
 * npm run bulk-update <project> <list>
 */
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const [migrationFolder, list = null] = args;
  const migrationFile = `${process.cwd()}/${migrationFolder}/migration.js`;
  // eslint-disable-next-line import/no-dynamic-require, global-require
  const migration = await import(migrationFile);
  const config = await migration.init(list);

  await main(config, migration.migrate);
  process.exit(0);
}
